extends ../../_layout/_layout_template

include ../../_layout/_layout_mixins

block title
  title Knockback-Inspector.js

block includes
  link(rel='stylesheet', href='css/tutorial.css')
  include ../../_layout/_layout_include_demo_scripts

block navbar
  mixin pageNavbar('Tutorials', false)

////////////////
// Overview
////////////////

block overview
  p Let's start with the goals of a simple model and collection inspector...

  h4 Model Injectionspector Goals
  ul
    li For each simple-typed attribute, provide a label for the attribute name and a text box to edit the value
    li For each model-typed attribute, provide a collapsable node with the attribute name and when opened, allow each model attribute to be inspected by type
    li For each collection-typed attribute, provide a collapsable node with the attribute name and when opened, allow each model to be inspected

  h4 Collection Inspector Goals
  ul
    li For each model-typed attribute, provide a collapsable node with the index model and when opened, allow each model attribute to be inspected bytype

  h3 Inspector Visualization
  p Here is what the inspector could look like for a house model that has a location (simple-typed attribute) and multiple occupants (collection-typed attribute) who each has an id (simple-typed attribute), a name (simple-typed attribute), and who know which house they are living in (model-typed attribute):
  img.screen_shot(src='img/tutorial_inspector/screen_shot_overview.png')
  br

  h3 HTML Templates

  p Given the recursiveness of the design, I chose to implement this functionality using two reusable HTML templates: one for a model node that generates HTML for each of its attributes and one for a collection node that generates HTML for each for its models:

  h4 Model Node View Structure (template: 'kbi_model_node')
  p Here is some pseudo-HTML for the model node:
  pre.
    <li data-bind="css: {opened: opened, closed: !opened()}">
      <div data-bind="click: function(){ opened(!opened()) }">
        <span data-bind="text: (opened() ? '- ' : '+ ' )"></span>
        <span data-bind="text: name"></span>
      </div>

      <!-- FOREACH ATTRIBUTE -->

        <!-- IF SIMPLE -->
          <fieldset>
            <label></label>
            <input type='text'>
          </fieldset>

        <!-- ELSE IF MODEL -->
          <!-- RENDER MODEL NODE -->

        <!-- ELSE IF COLLECTION -->
          <!-- RENDER COLLECTION NODE -->

    </li>
  strong Highlights:
  ul
    li Each model node uses a list item tag that can either be in opened or closed state
    li Use a div tag to wrap a +/- state indicator, the name of the node, and a click handler to toggle the opened/closed state of the node
    li The model attributes are grouped in a form tag
    li Each simple-typed attribute are wrapped in a fieldset tag in with a label tag and input tag for the name and value, respectively
    li Each model-typed attribute are rendered using the model node template
    li Each collection-typed attribute are rendered using the collection node template

  h4 Collection Node View Structure (template: 'kbi_collection_node')
  p Here is some pseudo-HTML for the collection node:
  pre.
    <li data-bind="css: {opened: opened, closed: !opened()}">
      <div data-bind="click: function(){ opened(!opened()) }">
        <span data-bind="text: (opened() ? '- ' : '+ ' )"></span>
        <span data-bind="text: name"></span>
      </div>

      <!-- FOREACH MODEL -->
        <!-- RENDER MODEL NODE -->
    </li>

  strong Highlights:
  ul
    li Each collection node uses a list item tag that can either be in opened or closed state
    li Use a div tag to wrap a +/- state indicator, the name of the node, and a click handler to toggle the opened/closed state of the node
    li The collection's models are wrapped in an unordered list tag and each model can be rendered using the model node template

////////////////
// Control Flow
////////////////
block control_flow
  p
    span Using Knockback.js, we can implement an inspector by:
    ol
      li Using Knockback to generate a graph starting at a kb.ViewModel or kb.CollectionObservable from a Backbone.Model or Backbone.Collection, respectively.
      li Using Knockout to traverse the graph, to wrap each kb.ViewModel node or kb.CollectionObservable node in a NodeViewModel, and to conditionally continue to render the graph depending on the opened/closed state of the node.

  h3 Graph Generation
  P
    span By default, a
    a(href='doc/classes/kb/ViewModel.html')  kb.ViewModel
    span will generate a kb.ViewModel for each of its nested models and a kb.collectionObservable for each of its nested collections when used like:
    pre kb.viewModel(my_model)
  P
    span Also, a
    a(href='doc/classes/kb/CollectionObservable.html')  kb.CollectionObservable
    span can easily be configured to generate a kb.ViewModel for each of its models when configured like:
    pre kb.collectionObservable(my_collection, {view_model: kb.ViewModel})
  P What this means is that Knockback takes care of circular references between Backbone.Models or Backbone.Collections so you don't have to. In the case of circular references, you just need to be careful to handle cycles correctly when you traverse the nodes in the graph.

  h3 Traversing the Graph
  p Because there can be cycles between the models and collections in the graph, the inspector uses a separate kbi.NodeViewModel to expose properties for the opened/closed state of the node, the name of the node, and the (potentially shared) node itself. A kbi.NodeViewModel is constructed with the following parameters: (name, opened_state, kb.ViewModel or kb.CollectionObservable).
  p By doing this, the same kb.ViewModel for a model can be opened or closed in different parts of the tree and can have unique names depending on where it is referenced from.
  p Also, each of the node templates, needs to take appropriate action to block the full tree from being rendered out when a kbi.NodeViewModel is in the closed state. With Knockout, this is easy to do using a '<!-- ko if: opened -->' control flow statement.

  p Updating the 'kbi_model_node' pseudo HTML:
  pre.
    <li data-bind="css: {opened: opened, closed: !opened()}">
      <div data-bind="click: function(){ opened(!opened()) }">
        <span data-bind="text: (opened() ? '- ' : '+ ' )"></span>
        <span data-bind="text: name"></span>
      </div>

      <!-- ko if: opened -->
        <!-- FOREACH ATTRIBUTE -->

          <!-- IF SIMPLE -->
            <fieldset>
              <label></label>
              <input type='text'>
            </fieldset>

          <!-- ELSE IF MODEL -->
            <ul data-bind="template: {name: 'kbi_model_node', data: kbi.nvm(attribute_name, false, node)}"></ul>

          <!-- ELSE IF COLLECTION -->
            <ul data-bind="template: {name: 'kbi_collection_node', data: kbi.nvm(attribute_name+'[]', true, node)}"></ul>

      <!-- /ko -->
    </li>
  p Updating the 'kbi_collection_node' pseudo HTML:
  pre.
    <li data-bind="css: {opened: opened, closed: !opened()}">
      <div data-bind="click: function(){ opened(!opened()) }">
        <span data-bind="text: (opened() ? '- ' : '+ ' )"></span>
        <span data-bind="text: name"></span>
      </div>

      <!-- ko if: opened -->
        <!-- FOREACH MODEL -->
          <ul data-bind="template: {name: 'kbi_model_node', data: kbi.nvm('['+$index()+']', false, node)}"></ul>
      <!-- /ko -->
    </li>

  p
    strong Please note:
    ul
      li Each kb.ViewModel or kb.CollectionObservable node is rendered with <ul> to start a new tree that is filled in by either the 'kbi_model_node' or 'kbi_collection_node' templates.
      li Each kbi.NodeViewModel is given a name to indicate its relationship.
      li In the case of models, the templates are rendered in a closed state to break potential cycles; whereas, collections are rendered in an open state so we are presented with the indices of the contained models.
      li When the node is closed, only the HTML that displays the name of the node and allows for a click to open the node is generated.

////////////////
// Library Architecture
////////////////
block library_architecture
  p Knockback-Inspector will be designed as a library with the following characteristics:
    ol
      li It will be in the 'kbi' namespace
      li It version will be available in 'kbi.VERSION'
      li
        span It code will be separated into multiple directories and files as follows:
        pre.
          - lib
            - kbi_core.js/.coffee
            - kbi_string_template_engine.js/.coffee
          - models
            - kbi_fetched.js/.coffee
          - view_models
            - kbi_node_view_model.js/.coffee
          - views
            - kbi_collection_node_view.js/.coffee
            - kbi_model_node_view.js/.coffee
      li
        span The files will contain the following implementations:
        h3 kbi_core.js/.coffee
        p Provides the kbi namespace and the kbi.VERSION semantic versioning string.
        h3 kbi_string_template_engine.js/.coffee
        p Implements kbi.TemplateSource and kbi.TemplateEngine to expose the 'kbi_model_node' and 'kbi_collection_node' templates to Knockout.js.
        h3 kbi_fetched.js/.coffee
        p Implements the kbi.FetchedModel and the kbi.FetchedCollection classes providing a Backbone.Model and a Backbone.Collection with the parse function that can be used to inspect a JSON server response when you do not have your own specialized implementations.
        h3 kbi_node_view_model.js/.coffee
        p Implements the kbi.NodeViewModel class to create a ViewModel instance for each kb.ViewModel or kb.CollectionObservable node in the graph with a name and opened state.
        p
          span Because the kbi.NodeViewModel class is shared for kb.ViewModel and kb.CollectionObservable nodes, in the case of kb.ViewModel, we need to add slightly more functionality to handle exposing and traversing the attributes:
          ul
            li
              strong Attribute Names:
              span  in order to be able to iterate through all of the attributes in a Backbone.Model with Knockout, we will store their names in an array.
            li
              strong Attribute Types:
              span  in order to select the correct attribute rendering in the template, we provide a helper function called 'kb.utils.valueType()' that returns the string kb.TYPE_SIMPLE, kb.TYPE_MODEL, or kb.TYPE_COLLECTION

        p
          span Updating the pseudo-HTML for the model node:
          pre.
            <li data-bind="css: {opened: opened, closed: !opened()}">
              <div data-bind="click: function(){ opened(!opened()) }">
                <span data-bind="text: (opened() ? '- ' : '+ ' )"></span>
                <span data-bind="text: name"></span>
              </div>

              <!-- ko if: opened -->
                <!-- ko foreach: attribute_names -->

                  <!-- ko if: (kb.utils.valueType($parent.node[$data]) == kb.TYPE_SIMPLE) -->
                    <fieldset>
                      <label data-bind="text: $data"> </label>
                      <input type='text' data-bind="value: $parent.node[$data]">
                    </fieldset>
                  <!-- /ko -->

                  <!-- ko if: (kb.utils.valueType($parent.node[$data]) == kb.TYPE_MODEL) -->
                    <ul data-bind="template: {name: 'kbi_model_node', data: kbi.nvm($data, false, $parent.node[$data])}"></ul>
                  <!-- /ko -->

                  <!-- ko if: (kb.utils.valueType($parent.node[$data]) == kb.TYPE_COLLECTION) -->
                    <ul data-bind="template: {name: 'kbi_collection_node', data: kbi.nvm($data+'[]', true, $parent.node[$data])}"></ul>
                  <!-- /ko -->

                <!-- /ko -->
              <!-- /ko -->

            </li>
        p Because Knockout.js pushes a new binding context on the stack during the iteration through the attribute_names, $data is mapped to the attribute name and the attribute itself can be accessed in the parent context using $parent.node[$data])
        h3 kbi_collection_node_view.js/.coffee
        p Provides kbi.CollectionNodeView which holds an HTML string that is used by the kbi.TemplateEngine whenever Knockout.js requests the 'kbi_collection_node' template.
        h3 kbi_model_node_view.js/.coffee
        p Provides kbi.ModelNodeView which holds an HTML string that is used by the kbi.TemplateEngine whenever Knockout.js requests the 'kbi_model_node' template.
    p OK. Let's start...

////////////////
// Step 1
////////////////
block step1
  p This tutorial demonstrates how to use Knockback to create a tree view to inspect Backbone.Model attributes and Backbone.Collection models including potentially recursive relationships between models.
  p
    span To show a JavaScript implementation in addition to a CoffeeScript implementation, the tutorial tries to take a native approach to each language so the implementations will be slightly different. That said, they will share the same structure:
    pre.
      - lib
        - kbi_core.js/.coffee
        - kbi_string_template_engine.js/.coffee
      - models
        - kbi_fetched.js/.coffee
      - view_models
        - kbi_node_view_model.js/.coffee
      - views
        - kbi_collection_node_view.js/.coffee
        - kbi_model_node_view.js/.coffee
    span Please see the library-architecture section for an overview on the structure and files.
  p
    span You can get access to the latest version of the library on
    a(href='https://github.com/kmalakoff/knockback-inspector/')  GitHub
    span  and you can find the code for this tutorial in the 'tutorials/javascript' and 'tutorials/coffeescript' folders.

  p Use the CoffeeScript and JavaScript radio button at the top of this page to choose your language of choice.

  ol
    li
      span Create a new project with the following structure:
      pre.
        - knockback-inspector
          - vendor
    li
      span Put all of the dependent libraries into the 'vendor' folder
      ul
        li
          a(href='http://jquery.com/') jQuery.js
        li
          a(href='https://github.com/SteveSanderson/knockout/downloads/') Knockout.js
        li
          a(href='http://documentcloud.github.com/underscore/') Underscore.js
        li
          a(href='http://documentcloud.github.com/backbone/') Backbone.js
        li
          a(href='http://kmalakoff.github.com/knockback/') Knockback.js
        li
          a(href='https://github.com/PaulUithol/Backbone-relational/') Backbone-Relational (optional, but recommended)

    li
      span Create an index.html file in the root project directory referring to all the dependencies like (updating path, version and production/development version naming to match your files):
      pre.
        - knockback-inspector
          - index.html
          - vendor
      pre.
        <!doctype html>
        <head>
          <meta charset='utf-8'>
          <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
          <title>Knockback Inspector</title>

          <!-- DEPENDENCIES -->
          <script src='vendor/jquery-1.9.1.js'></script>
          <script src='vendor/knockback-core-stack-0.17.1.js'></script>
          <script src='vendor/backbone-relational-0.8.0plus.js'></script>

          <!-- APPLICATION STYLING -->
          <style type='text/css'>
          #content {width: 800px; margin: 0 auto; background-color: #F5E0FF; border-radius: 5px;}
          h1 {text-align: center; font-size: 2em; color: #fff; background-color: #CC66FF; border-radius: 5px;}
          </style>

        </head>
        <body>
          <div id='content'>
            <h1>Knockback Inspector</h1>
          </div>
        </body>
        </html>
    li
      span Now open your index.html. You should see 'Knockback Inspector' in the page and there should be no missing file errors in your browser's debugger.
    li(data-for='cs')
      span Install
      a(href='http://nodejs.org/')  Node.js
    li(data-for='cs')
      span Install CoffeeScript using the Node Package Manager (npm)
      pre.
        (sudo) npm install -g coffee-script
    li(data-for='cs')
      span Update the project with the /src folder for each library component and an executable Cakefile to compile the coffeejs from /src into /js:
      pre.
        - knockback-inspector
          - Cakefile
          - index.html
          - js
          - src
            - lib
            - models
            - view_models
            - views
          - vendor
      span You can find information on how to set up a Cakefile for build and watch commands in
      a(href='http://arcturo.github.com/library/coffeescript/05_compiling.html')  The Little Book on CoffeeScript - Compiling
      span . I slightly modified the book examples to compile to the output directory of /js.
      pre.
        {print} = require 'util'
        {spawn} = require 'child_process'
        path = require 'path'

        task 'build', 'Build js/ from src/', ->
          coffee = spawn 'coffee', ['-c', '-o', 'js', 'src']
          coffee.stderr.on 'data', (data) ->
            process.stderr.write data.toString()
          coffee.stdout.on 'data', (data) ->
            print data.toString()
          coffee.on 'exit', (code) ->
            callback?() if code is 0

        task 'watch', 'Watch src/ for changes', ->
          coffee = spawn 'coffee', ['-w', '-o', 'js', 'src']
          coffee.stderr.on 'data', (data) ->
            print 'Error'
            process.stderr.write data.toString()
          coffee.stdout.on 'data', (data) ->
            print data.toString()
            callback?()
    li(data-for='cs')
      p Next, create /lib/kbi_core.coffee to implement the kbi namespace and semantic version string
      pre.
        @kbi or={}
        @kbi.VERSION = '0.1.0'
      p Use 'cake build' or 'cake watch' to compile the CoffeeScript to /js
    li(data-for='js')
      span Update the project with the /js folder for each library component:
      pre.
        - knockback-inspector
          - index.html
          - js
            - lib
            - models
            - view_models
            - views
          - vendor
    li(data-for='js')
      p Next, create /lib/kbi_core.js to implement the kbi namespace and semantic version string
      pre.
        this.kbi || (this.kbi = {});
        this.kbi.VERSION = '0.1.0';
    li
      p Finally, let's update the index.html file to include /javjs/kbi_core.js, to display the version number using Knockback.js, and to add some styling:
      pre.
        <!doctype html>
        <head>
          <meta charset='utf-8'>
          <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
          <title class='inspector_title' data-bind="text: title"></title>

          <!-- DEPENDENCIES -->
          <script src='vendor/jquery-1.9.1.js'></script>
          <script src='vendor/knockback-core-stack-0.17.1.js'></script>
          <script src='vendor/backbone-relational-0.8.0plus.js'></script>

          <!-- KNOCKBACK-INSPECTOR LIBRARY -->
          <script src='js/lib/kbi_core.js'></script>

          <!-- APPLICATION STYLING -->
          <style type='text/css'>
          #content {width: 800px; margin: 0 auto; background-color: #F5E0FF; border-radius: 5px;}
          h1 {text-align: center; font-size: 2em; color: #fff; background-color: #CC66FF; border-radius: 5px;}
          </style>

        </head>
        <body>
          <div id='content'>
            <h1 class='inspector_title' data-bind="text: title"></h1>

            <!-- Step 1: Setting up the Project -->
            <script type='text/javascript'>
              var   app_model = new Backbone.Model({title: 'Knockback Inspector (' + kbi.VERSION + ')'});
              $('.inspector_title').each(function(){ ko.applyBindings(kb.viewModel(app_model), this); });
            </script>

          </div>
        </body>
        </html>
      p
        span To explain the changes to index.html:
        ul
          li
            span The two hardcoded 'Knockback Inspector' title strings were replaced with Knockout.js bindings in the tag (and given an 'inspector_title' class):
            pre <some_tag class='inspector_title' data-bind="text: title"></some_tag>
          li
            span To use Knockback.js, we create a Backbone.Model with a an attribute called 'title' and then use Knockout.js to bind each DOM element with the 'inspector_title' class to a kb.ViewModel using the kb.viewModel factory function:
            pre.
              <!-- Step 1: Setting up the Project -->
              <script type='text/javascript'>
                var   app_model = new Backbone.Model({title: 'Knockback Inspector (' + kbi.VERSION + ')'});
                $('.inspector_title').each(function(){ ko.applyBindings(kb.viewModel(app_model), this); });
              </script>

      p When you reload index.html, the browser title and header should display 'Knockback Inspector (0.1.0)' with formatting like:
      br
      img.screen_shot(src='img/tutorial_inspector/screen_shot_step1.png')
      br

////////////////
// Step 2
////////////////
block step2
  p
    span This step shows how to render a Backbone.Model with a relations in a collection-typed attribute named friends. First, let's put the following in index.html inside the content div:
    pre.
      <body>
        <div id='content'>
          ...

          <!-- Step 2: Rendering a Backbone.Model using kb.ViewModel -->
          <ul id='backbone_model' class='kbi root' data-bind="template: {name: 'kbi_model_node', data: kbi.nvm('root', true, $data)}"></ul>
          <script type='text/javascript'>
            var model1 = new Backbone.Model({name: 'Model1', pet: 'frog', friends: new Backbone.Collection([])});
            var model2 = new Backbone.Model({name: 'Model2', pet: 'dog', friends: new Backbone.Collection([])});
            var model3 = new Backbone.Model({name: 'Model3', pet: '(none)', friends: new Backbone.Collection([])});
            model1.get('friends').reset([model2, model3]);
            model2.get('friends').reset([model1, model3]);
            model3.get('friends').reset([model1, model2]);

            ko.applyBindings(kb.viewModel(model1), $('#backbone_model')[0]);
          </script>

          ...
        </div>
      </body>
    span You should recognize the unordered list HTML from the Control Flow and Library Architecture sections (if not, please review those sections):
    pre.
      <ul id='backbone_model' class='kbi root' data-bind="template: {name: 'kbi_model_node', data: kbi.nvm('root', true, $data)}"></ul>
    span This unordered list tag starts a new tree in the DOM that is found by jQuery using the #backbone_model id selector and is bound by Knockout.js using:
    pre.
      ko.applyBindings(kb.viewModel(model1), $('#backbone_model')[0]);
    span Because Knockout is binding directly to the kb.ViewModel in ko.applyBindings, we can access the kb.ViewModel using $data when the kbi.nvm is created.

  p
    span Let's start by implementing the kbi.NodeViewModel which contains a name ('root'), an opened state (true), and the kb.ViewModel node ($data). A shared implementation for both a kb.ViewModel and a kb.CollectionObservable would be as follows:

  div(data-for='cs')
    h3 Create /src/view_models/kbi_node_view_model.coffee:
    pre.
      class kbi.NodeViewModel
        constructor: (@name, opened, @node) ->
          @opened = ko.observable(opened)
          if ko.utils.unwrapObservable(node) instanceof kb.ViewModel
            @node = ko.utils.unwrapObservable(node) # store unwrapped view model

      # factory
      kbi.nodeViewModel = kbi.nvm = (name, opened, node) -> return new kbi.NodeViewModel(name, opened, node)
  p kbi.nodeViewModel() and kbi.nvm() are factory functions to help reduce the verbosity of the code in the templates.
  div(data-for='js')
    h3 Create /js/view_models/kbi_node_view_model.js:
    pre.
      kbi.NodeViewModel = function(name, opened, node) {
        this.name = name;
        this.opened = ko.observable(opened);
        this.node = node;
        if (ko.utils.unwrapObservable(node) instanceof kb.ViewModel) {
          this.node = ko.utils.unwrapObservable(node); // store unwrapped view model
        }
      };

      // factory
      kbi.nodeViewModel = kbi.nvm = function(name, opened, node) { return new kbi.NodeViewModel(name, opened, node); };
    p kbi.nodeViewModel() and kbi.nvm() are factory functions to help reduce the verbosity of the code in the templates.
    span <strong>Note:</strong> the node needs to be unwrapped because when Knockback generates kb.ViewModels and kb.Collection observables for nested Backbone.Models and Backbone.Collections, it wraps them in ko.Observables in case the underlying relationship changes.

  h2='kbi.NodeViewModel'
  p
    span Next, we will add the attribute functionality used for Backbone.Model's kb.ViewModels:
    pre(data-for='cs').
      class kbi.NodeViewModel
        constructor: (@name, opened, @node) ->
          @opened = ko.observable(opened)

          # a kb.ViewModel indicates the node is a Backbone.Model
          if (ko.utils.unwrapObservable(@node) instanceof kb.ViewModel)
            @node = ko.utils.unwrapObservable(@node) # store unwrapped view model
            model = kb.utils.wrappedModel(@node)
            @attribute_names = ko.observableArray(if model then _.keys(model.attributes) else [])
          @

      # factory
      kbi.nodeViewModel = kbi.nvm = (name, opened, node) -> return new kbi.NodeViewModel(name, opened, node)
    pre(data-for='js').
      kbi.NodeViewModel = function(name, opened, node) {
        this.name = name;
        this.opened = ko.observable(opened);
        this.node = node;

        // a kb.ViewModel indicates the node is a Backbone.Model
        if (ko.utils.unwrapObservable(node) instanceof kb.ViewModel) {
          this.node = ko.utils.unwrapObservable(node); // store unwrapped view model
          var model = kb.utils.wrappedModel(this.node);
          this.attribute_names = ko.observableArray(model ? _.keys(model.attributes) : []);
        }
      };

      // factory
      kbi.nodeViewModel = kbi.nvm = function(name, opened, node) { return new kbi.NodeViewModel(name, opened, node); };
    span The new code in the constructor just collects all of the attribute names and the valueType(key) function just checks the property in the kb.ViewModel for its type rather than performing this check directly in the template.

  h2='Views'
  p
    span Next, we will finalize the View templates for each node type as started in the Control Flow and Library Architecture sections. Because Knockout handles all of the dynamic aspects of the template, we can simply use a static string for our templates.

  h3 Template: 'kbi_model_node'
  div(data-for='cs')
    h4 Create /src/views/kbi_model_node_view.coffee:
    pre.
      kbi.ModelNodeView = """
      <li class='kbi' data-bind="css: {opened: opened, closed: !opened()}">
        <div class='kbi model' data-bind="click: function(){ opened(!opened()); }">
          <span data-bind="text: (opened() ? '- ' : '+ ' )"></span>
          <span data-bind="text: name"></span>
        </div>

        <!-- ko if: opened -->
          <!-- ko foreach: attribute_names -->

            <!-- ko if: (kb.utils.valueType($parent.node[$data]) == kb.TYPE_SIMPLE) -->
              <fieldset class='kbi'>
                <label data-bind="text: $data"> </label>
                <input type='text' data-bind="value: $parent.node[$data]">
              </fieldset>
            <!-- /ko -->

            <!-- ko if: (kb.utils.valueType($parent.node[$data]) == kb.TYPE_MODEL) -->
              <ul class='kbi' data-bind="template: {name: 'kbi_model_node', data: kbi.nvm($data, false, $parent.node[$data])}"></ul>
            <!-- /ko -->

            <!-- ko if: (kb.utils.valueType($parent.node[$data]) == kb.TYPE_COLLECTION) -->
              <ul class='kbi' data-bind="template: {name: 'kbi_collection_node', data: kbi.nvm($data+'[]', true, $parent.node[$data])}"></ul>
            <!-- /ko -->

          <!-- /ko -->
        <!-- /ko -->
      </li>
      """
  div(data-for='js')
    h4 Create /js/views/kbi_model_node_view.js:
    pre.
      kbi.ModelNodeView = "<li class='kbi' data-bind=\"css: {opened: opened, closed: !opened()}\"> \
        <div class='kbi model' data-bind=\"click: function(){ opened(!opened()); }\"> \
          <span data-bind=\"text: (opened() ? '- ' : '+ ' )\"></span> \
          <span data-bind=\"text: name\"></span> \
        </div> \
      \
        <!-- ko if: opened --> \
          <!-- ko foreach: attribute_names --> \
      \
            <!-- ko if: (kb.utils.valueType($parent.node[$data]) == kb.TYPE_SIMPLE) --> \
              <fieldset class='kbi'> \
                <label data-bind=\"text: $data\"> </label> \
                <input type=\"text\" data-bind=\"value: $parent.node[$data]\"> \
              </fieldset> \
            <!-- /ko --> \
      \
            <!-- ko if: (kb.utils.valueType($parent.node[$data]) == kb.TYPE_MODEL) --> \
              <ul class='kbi' data-bind=\"template: {name: 'kbi_model_node', data: kbi.nvm($data, false, $parent.node[$data])}\"></ul> \
            <!-- /ko --> \
      \
            <!-- ko if: (kb.utils.valueType($parent.node[$data]) == kb.TYPE_COLLECTION) --> \
              <ul class='kbi' data-bind=\"template: {name: 'kbi_collection_node', data: kbi.nvm($data+'[]', true, $parent.node[$data])}\"></ul> \
            <!-- /ko --> \
      \
          <!-- /ko --> \
        <!-- /ko --> \
      </li>";
    span <strong>Note:</strong> In order to make multi-line strings, we put a '\' at the end of each continuing line.
  p
    span This template is similar to the last pseudo HTML in the Library Architecture section with a few changes to make it a polished template:
    ul
      li The 'kbi' and kb.TYPE_MODEL classes have been added for css styling
      li Knockout if control flow comments have been specified to render the correct template section based on the attribute type
      li Because 'foreach: attribute_names' creates a new binding context inside the loop, we can access the actual kbi.NodeViewModel using $parent and the attribute name using $data.

  h3 Template: 'kbi_collection_node'
  div(data-for='cs')
    h4 Create /src/views/kbi_collection_node_view.coffee:
    pre.
      kbi.CollectionNodeView = """
      <li class='kbi' data-bind="css: {opened: opened, closed: !opened()}">
        <div class=kb.TYPE_COLLECTION data-bind="click: function(){ opened(!opened()) }">
          <span data-bind="text: (opened() ? '- ' : '+ ' )"></span>
          <span data-bind="text: name"></span>
        </div>

        <!-- ko if: opened -->
          <!-- ko foreach: node -->
            <ul class='kbi' data-bind="template: {name: 'kbi_model_node', data: kbi.nvm('['+$index()+']', false, $data)}"></ul>
          <!-- /ko -->
        <!-- /ko -->
      </li>
      """
  div(data-for='js')
    h4 Create /js/views/kbi_collection_node_view.js:
    pre.
      kbi.CollectionNodeView = " \
      <li class='kbi' data-bind=\"css: {opened: opened, closed: !opened()}\"> \
        <div class=kb.TYPE_COLLECTION data-bind=\"click: function(){ opened(!opened()) }\"> \
          <span data-bind=\"text: (opened() ? '- ' : '+ ' )\"></span> \
          <span data-bind=\"text: name\"></span> \
        </div> \
      \
        <!-- ko if: opened --> \
          <!-- ko foreach: node --> \
            <ul class='kbi' data-bind=\"template: {name: 'kbi_model_node', data: kbi.nvm('['+$index()+']', false, $data)}\"></ul> \
          <!-- /ko --> \
        <!-- /ko --> \
      </li>";
    span <strong>Note:</strong> In order to make multi-line strings, we put a '\' at the end of each continuing line.
  p
    span This template is similar to the last pseudo HTML in the Library Architecture section with a few changes to make it a polished template:
    ul
      li The 'kbi' and kb.TYPE_COLLECTION classes have been added for css styling
      li Because the kb.CollectionObservable is actually a ko.observableArray, we can access its items (which contain kb.ViewModels for each Backbone.Model) using 'foreach: node'
      li Because 'foreach: node' creates a new binding context inside the loop, we access each kb.ViewModel using $data.

  h2 Exposing the Templates to Knockout
  p
    span Knockout works out of the box on a static HTML page where all templates are inlined, but because we need to render graphs meaning 'kbi_collection_node' and 'kbi_model_node' can refer to one another, we store the templates as strings and need to provide them to Knockout whenever it encounters them in a tag with data-bind="template: {name: 'template_name', data: some_data }".
  p
    span There are two things Knockout requires for this: 'templateEngine' and 'templateSource': you can look at
    a(href='http://www.knockmeout.net/2011/10/ko-13-preview-part-3-template-sources.html')  an in-depth online tutorial
    span but for now, I'll try to keep the code and support to a minimum.

  div(data-for='cs')
    h4 Create /src/lib/kbi_string_template_engine.coffee:
    pre.
      # template source
      class kbi.TemplateSource
        constructor: (@template_string) ->
        text: (value) -> return @template_string

      # template engine
      class kbi.TemplateEngine extends ko.nativeTemplateEngine
        constructor: ->
          @allowTemplateRewriting = false

        makeTemplateSource: (template) ->
          switch (template)
            when 'kbi_model_node' then return new kbi.TemplateSource(kbi.ModelNodeView)
            when 'kbi_collection_node' then return new kbi.TemplateSource(kbi.CollectionNodeView)
            else return ko.nativeTemplateEngine.prototype.makeTemplateSource.apply(this, arguments)  div(data-for='js')

  div(data-for='js')
    h4 Create /js/lib/kbi_string_template_engine.js:
    pre.
      // template source
      kbi.TemplateSource = function(template_string) { this.template_string = template_string; };
      kbi.TemplateSource.prototype.text = function(value) { return this.template_string; };

      // template engine
      kbi.TemplateEngine = function() { this.allowTemplateRewriting = false; };
      kbi.TemplateEngine.prototype = new ko.nativeTemplateEngine();
      kbi.TemplateEngine.prototype.makeTemplateSource = function(template) {
        switch (template) {
          case 'kbi_model_node':
            return new kbi.TemplateSource(kbi.ModelNodeView);
          case 'kbi_collection_node':
            return new kbi.TemplateSource(kbi.CollectionNodeView);
          default:
            return ko.nativeTemplateEngine.prototype.makeTemplateSource.apply(this, arguments);
        }
      };
  p
    span The kbi.TemplateSource class simply stores a string and returns it when text() is called.
  p
    span The kbi.TemplateEngine class is derived from ko.nativeTemplateEngine, uses this.allowTemplateRewriting to tell Knockout that the template source is very simple, and implements a makeTemplateSource() function to look up the template by name.

  h3 Register kbi.TemplateEngine with Knockout
  p
    span Setting the template engine is done in the index.html file rather than the library so you can hook up your own template engine implementation as you need depending on which template engine you are using.
  p
    span For this tutorial, add the following to index.html after the Knockout-Inspector library, but before you use a 'kbi_model_node' or 'kbi_collection_node' template:
    pre.
      <!-- KNOCKOUT INITIALIZATION -->
      <script type='text/javascript'>
        // set the template engine so Knockout can find 'kbi_model_node' and 'kbi_collection_node' templates
        ko.setTemplateEngine(new kbi.TemplateEngine());
      </script>
  p
    span <strong>Note:</strong> if you are integrating Knockback-Inspector into your own application and you are not using the default Knockout template engine, you will to write a register your own template engine with Knockout. You can use kbi.TemplateEngine as a starting point.

  h2 Hooking up the library
  p Finally, add all of the javascript files to index.html and try it out!
  pre.
    <!-- KNOCKBACK-INSPECTOR LIBRARY -->
    <script src='js/lib/kbi_core.js'></script>
    <script src='js/view_models/kbi_node_view_model.js'></script>
    <script src='js/views/kbi_collection_node_view.js'></script>
    <script src='js/views/kbi_model_node_view.js'></script>
    <script src='js/lib/kbi_string_template_engine.js'></script>

  p
    span You should see something like:
    br
    img.screen_shot(src='img/tutorial_inspector/screen_shot_step2.png')
    br

////////////////
// Step 3
////////////////
block step3
  p
    span Because we already have an implementation for 'kbi_collection_node' and kbi.NodeViewModel can be used with both kb.ViewModels and kb.CollectionObservables, we should be able to render a tree starting with a kb.CollectionObservable as follows:
    pre.
      <ul data-bind="template: {name: 'kbi_collection_node', data: kbi.nvm('root', true, kb.collectionObservable(collection, {view_model: kb.ViewModel}))}"></ul>
    span <strong>Note:</strong> the kb.CollectionObservable requires the view_model option because by default it stores the collection models rather than generating kb.ViewModels.
  p
    span Let's use Backbone-Relational to generate some relations and then render the relations:
    pre.
      <!-- Step 3: Rendering a BackboneRelational using kb.CollectionObservable -->
      <ul id='backbone_relational' class='kbi root' data-bind="template: {name: 'kbi_collection_node', data: kbi.nvm('root', true, $data)}"></ul>
      <script type='text/javascript'>
        var Person = Backbone.RelationalModel.extend({});
        var House = Backbone.RelationalModel.extend({
          relations: [{
            type: Backbone.HasMany,
            key: 'occupants',
            relatedModel: 'Person',
            reverseRelation: {
              key: 'livesIn'
            }
          }]
        });

        var bob = new Person({id: 'person-1', name: 'Bob'});
        var fred = new Person({id: 'person-2', name: 'Fred'});
        var house = new House({
          location: 'In the middle of our street',
          occupants: ['person-1', 'person-2']
        });

        ko.applyBindings(kb.collectionObservable(house.get('occupants'), {view_model: kb.ViewModel}), $('#backbone_relational')[0]);
      </script>

  p
    span It just works!
    br
    img.screen_shot(src='img/tutorial_inspector/screen_shot_step3.png')
    br

////////////////
// Step 4
////////////////
block step4
  p To provide a general purpose way to inspect JSON data returned from a Backbone.Model or Backbone.Collection fetch call, we will implement kbi.FetchedModel and kbi.FetchedCollection that are generated when we traverse the returned JSON.
  div(data-for='cs')
    h4 Create /src/models/kbi_fetched.coffee:
    pre.
      # General-purpose model for fetched JSON when you do not have a specialized implementation
      class kbi.FetchedModel extends Backbone.Model
        parse: (response) ->
          attributes = {}
          for key, value of response
            if _.isObject(value)
              model = new kbi.FetchedModel()
              attributes[key] = model.set(model.parse(value))
            else if _.isArray(value)
              collection = new kbi.FetchedCollection()
              attributes[key] = collection.reset(collection.parse(value))
            else
              attributes[key] = value
          return attributes

      # General-purpose collection for fetched JSON when you do not have a specialized implementation
      class kbi.FetchedCollection extends Backbone.Collection
        model: kbi.FetchedModel
        parse: (response) -> return _.map(response.results, (result) ->
          model = new kbi.FetchedModel()
          return model.set(model.parse(result))
        )
  div(data-for='js')
    h4 Create /js/models/kbi_fetched.js:
    pre.
      // General-purpose model for fetched JSON when you do not have a specialized implementation
      kbi.FetchedModel = Backbone.Model.extend({
        parse: function(response) {
          var attributes, collection, key, model, value;
          attributes = {};
          for (key in response) {
            value = response[key];
            if (_.isObject(value)) {
              model = new kbi.FetchedModel();
              attributes[key] = model.set(model.parse(value));
            } else if (_.isArray(value)) {
              collection = new kbi.FetchedCollection();
              attributes[key] = collection.reset(collection.parse(value));
            } else {
              attributes[key] = value;
            }
          }
          return attributes;
        }
      });

      // General-purpose collection for fetched JSON when you do not have a specialized implementation
      kbi.FetchedCollection = Backbone.Collection.extend({
        model: kbi.FetchedModel,
        parse: function(response) {
          return _.map(response.results, function(result) {
            var model = new kbi.FetchedModel();
            return model.set(model.parse(result));
          });
        }
      });
  p When parsing the data, kbi.FetchedModel generates kbi.FetchedModel when it encounters a JSON object, generates a kbi.FetchedCollection when it encounters a JSON array, and otherwise, it just stores the simple type in the attribute.
  p
    span We can use the kbi.FetchedCollection and a kb.CollectionObservable to render a tree of the data returned from a Twitter query as follows:
    pre.
      <!-- Step 4: Rendering a Twitter Query using kb.CollectionObservable -->
      <ul class='kbi root' id='fetched_collection'>
        <li class='kbi'>
          <fieldset class='kbi'>
            <label>URL</label>
            <input type='text' data-bind="value: url">
          </fieldset>
          <ul class='kbi' data-bind="template: {name: 'kbi_collection_node', data: kbi.nvm('root', true, collection)}"></ul>
        </li>
      </ul>

      <script type='text/javascript'>
        var   custom_url_model = new Backbone.Model({url: '', collection: new kbi.FetchedCollection()});
        var   view_model = kb.viewModel(custom_url_model);
        view_model.url.subscribe(function(url){
          custom_url_model.get(kb.TYPE_COLLECTION).url = url;
          custom_url_model.get(kb.TYPE_COLLECTION).fetch();
        });

        ko.applyBindings(view_model, $('#fetched_collection')[0]);
        view_model.url('http://search.twitter.com/search.json?q=knockbackjs&callback=?');
      </script>
    p
      span To explain:
      ul
        li We create a Backbone.Model with the url (string) and collection (kbi.FetchedCollection) attributes and we use Knockback to create a kb.ViewModel with url and collection Knockout observable properties
        li We use Knockout to subscribe to the url observable to be notified when the url changes and when it does, we set the collection url and perform a fetch using Backbone's ORM.
        li We initialize the url value after everything is set up so the first fetch is triggered.

  p
    span You should be able to change the twitter search query or enter any RESTful, public url that returns JSON with a results array.
    br
    img.screen_shot(src='img/tutorial_inspector/screen_shot_step4.png')
    br

////////////////
// Step 5
////////////////
block step5

  p The last step is to turn the library into a single file named 'knockback-inspector.min.js', wrap it in an anonymous function, and to minimize it. For CoffeeScript, this can be achieved by updating the Cakefile as follows:
  pre.
    {print} = require 'util'
    {spawn} = require 'child_process'
    path = require 'path'

    callback = ->
      spawn 'uglifyjs', ['-o', 'knockback-inspector.min.js', 'knockback-inspector.js']
      print "\#{(new Date).toLocaleTimeString()} - generated knockback-inspector.min.js\n"

    task 'build', 'Build js/ from src/', ->
      coffee = spawn 'coffee', ['-c', '-j', 'knockback-inspector.js', 'src']
      coffee.stderr.on 'data', (data) ->
        process.stderr.write data.toString()
      coffee.stdout.on 'data', (data) ->
        print data.toString()
      coffee.on 'exit', (code) ->
        callback?() if code is 0

    task 'watch', 'Watch src/ for changes', ->
      coffee = spawn 'coffee', ['-w', '-o', '.', '-j', 'knockback-inspector.js', 'src']
      coffee.stderr.on 'data', (data) ->
        print 'Error'
        process.stderr.write data.toString()
      coffee.stdout.on 'data', (data) ->
        print data.toString()
        callback?()
  p The difference are that now we are using the -j (or --join) option without generating temporary files in the /js directory and we implemented a callback to uglify the knockback-inspector.js whenever it changed.
  p <strong>Note:</strong> if you are using JavaScript, you can use the scripting language of your choice to concatenate and minimize the individual JavaScript files into 'knockback-inspector.min.js'.


////////////////
// Future Enhancements
////////////////
block future_enhancements
  p
    span The inspector works for the most part, but as with anything it can always be improved! Here are some ideas:
    ul
      li
        strong Customized Attribute Editing
        span : currently, each attribute can be edited using a text box, but for some attribute types, this isn't very useful. Specific attribute editors could be rendered depending on the attribute type.
      li
        strong Handling attributes being added or removed
        span : currently, the attribute names are stored in the kbi.NodeViewModel when the model is initially checked. We could watch for change events and update the attributes lists accordingly
      li
        strong Customized Styling:
        span when I initially implemented the inspector, I used Twitter Bootstrap to provide styling and icons, but in the released version, I removed the dependency. Perhaps there should be hooks in the templates to customize more styling aspects of the inspector?
      li
        strong Model and Collection Editing:
        span Currently, attributes cannot be added or removed to models and models cannot be added or remove to/from collections.'
      li
        strong RESTful Server Actions
        span : Currently, you can easily GET from a server, but there is no ability to POST or PUT. Some action buttons or functionality could be added.

  p If you would like to implement these enhancements (or any others that would be generally useful) and contribute them back to the project, please just submit a pull request.

block content
  section
    h1 Tutorial (Advanced): Knockback-Inspector.js

    p This tutorial shows how to create an inspector for a Backbone.Model or a Backbone.Collection that you can embed in your website for debugging purposes. For a model, the inspector allows you to view and edit its attributes including nested models and collections; for a collection, the inspector allows you to view and edit its models.

    p
      span <strong>Note:</strong> because this is an intermediate tutorial, you should already have reviewed the
      a(href='tutorials_introduction.html')  Tutorial Introduction
      span  before attempting this one.

    h3 Try out the Knockback-Inspector:
    iframe(style='width: 100%; height: 450px', src='http://jsfiddle.net/kmalakoff/FRhEV/embedded/result,js,html,resources/', allowfullscreen='allowfullscreen', frameborder='0')

    p
    p
      span Although the inspector can be useful as presented in this tutorial, this version is simple and stripped down for learning purposes (the tutorial may not match the live demo).
    p
      span Please download
      a(href='https://github.com/kmalakoff/knockback-inspector/')  the Knockout-Inspector project from GitHub
      span  and follow along with each step of this tutorial in the /tutorials/step folder.
    p <strong>Let's begin...</strong>

    div.accordion#sections
      div.accordion-group
        div.accordion-heading
          a.accordion-toggle(data-toggle='collapse', href='#collapseOverview') Overview
        div.accordion-body.collapse#collapseOverview(style='height: 0px;')
          div.accordion-inner
            block overview
      div.accordion-group
        div.accordion-heading
          a.accordion-toggle(data-toggle='collapse', href='#collapseControlFlow') Control Flow
        div.accordion-body.collapse#collapseControlFlow(style='height: 0px;')
          div.accordion-inner
            block control_flow
      div.accordion-group
        div.accordion-heading
          a.accordion-toggle(data-toggle='collapse', href='#collapseLibraryArchitecture') Library Architecture
        div.accordion-body.collapse#collapseLibraryArchitecture(style='height: 0px;')
          div.accordion-inner
            block library_architecture
      div.accordion-group
        div.accordion-heading
          a.accordion-toggle(data-toggle='collapse', href='#collapseStep1') Step 1: Setting up the Project
        div.accordion-body.collapse#collapseStep1(style='height: 0px;')
          div.accordion-inner
            block step1
      div.accordion-group
        div.accordion-heading
          a.accordion-toggle(data-toggle='collapse', href='#collapseStep2') Step 2: Rendering a Backbone.Model using kb.ViewModel
        div.accordion-body.collapse#collapseStep2(style='height: 0px;')
          div.accordion-inner
            block step2
      div.accordion-group
        div.accordion-heading
          a.accordion-toggle(data-toggle='collapse', href='#collapseStep3') Step 3: Rendering a BackboneRelational using kb.CollectionObservable
        div.accordion-body.collapse#collapseStep3(style='height: 0px;')
          div.accordion-inner
            block step3
      div.accordion-group
        div.accordion-heading
          a.accordion-toggle(data-toggle='collapse', href='#collapseStep4') Step 4: Rendering a Twitter Query using kb.CollectionObservable
        div.accordion-body.collapse#collapseStep4(style='height: 0px;')
          div.accordion-inner
            block step4
      div.accordion-group
        div.accordion-heading
          a.accordion-toggle(data-toggle='collapse', href='#collapseStep5') Step 5: Create a Reusable Library Version <strong>(CoffeeScript Only)</strong>
        div.accordion-body.collapse#collapseStep5(style='height: 0px;')
          div.accordion-inner
            block step5
      div.accordion-group
        div.accordion-heading
          a.accordion-toggle(data-toggle='collapse', href='#collapseFutureEnhancements') Future Enhancements
        div.accordion-body.collapse#collapseFutureEnhancements(style='height: 0px;')
          div.accordion-inner
            block future_enhancements